## 数组——进阶题

## 把数组排成最小的数

剑指Offer45

### 题目

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 

例如输入数组`{3，32，321}`，则打印出这三个数字能排成的最小数字为`321323`。

### 思路

对数组进行排序，再连接字符串

定义一种新的排序规则，将整个数组重新排序：

`a`和`b`两个数字可以有两种组合：`ab`和`ba`，若`ab<ba`则`ab`应该排在`ba`前面，否则`ab`应该排在`ba`后面。

使用数组的`sort`方法，底层是快排，也可以手写一个快排。

> `sort`方法接收一个比较函数，`compareFunction`：如果 `compareFunction(a, b)` 小于 `0` ，那么 `a` 会被排列到 `b` 之前；

```js
var minNumber = function(numbers) {
	if (!numbers || numbers.length === 0) {
        return "";
    }
    return numbers.sort(compare).join('');
};

function compare(a, b) {
    const front = "" + a + b;
    const behind = "" + b + a;
    return front - behind;
}
```

![image-20210114114553716](../img/image-20210114114553716.png)

## 数组的逆序对

### 题目

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

**示例 1:**

```
输入: [7,5,6,4]
输出: 5
```

### 思路

#### 解法1 暴力法 不可行！

两重循环（有可能超时），使用暴力法：从第一个数开始，依次和后面每一个数字进行比较记录逆序对的个数，时间复杂度O(n2)

#### 解法2 分治法

直接将归并排序进行改进，把数据分成`N`个小数组。

合并数组 `left - mid` , `mid+1 - right`，合并时， 若`array[leftIndex] > array[rightIndex]` ,则比右边 `rightIndex-mid`个数大

```
count += rightIndex-mid
```

注意和归并排序的区别： 归并排序是合并数组数从小数开始，而本题是从大数开始。

时间复杂度`O(nlogn)`

空间复杂度`O(n)`

## 在排序数组中查找数字

